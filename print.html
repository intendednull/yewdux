<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Yewdux</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Quickstart</li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="example.html"><strong aria-hidden="true">2.</strong> Example</a></li><li class="chapter-item expanded affix "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="store.html"><strong aria-hidden="true">3.</strong> Store</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="default_store.html"><strong aria-hidden="true">3.1.</strong> Default value</a></li><li class="chapter-item expanded "><a href="persistence.html"><strong aria-hidden="true">3.2.</strong> Persistence</a></li><li class="chapter-item expanded "><a href="derived_state.html"><strong aria-hidden="true">3.3.</strong> Derived State</a></li></ol></li><li class="chapter-item expanded "><a href="dispatch.html"><strong aria-hidden="true">4.</strong> Writing state</a></li><li class="chapter-item expanded "><a href="reading.html"><strong aria-hidden="true">5.</strong> Reading state</a></li><li class="chapter-item expanded "><a href="listeners.html"><strong aria-hidden="true">6.</strong> Listeners</a></li><li class="chapter-item expanded "><a href="context.html"><strong aria-hidden="true">7.</strong> Contexts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ssr.html"><strong aria-hidden="true">7.1.</strong> SSR Support</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Yewdux</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>A state management solution for the <a href="https://yew.rs">Yew</a> front-end library.</p>
<p>This crate was inspired by <a href="https://redux.js.org/">Redux</a>, however some deviation was taken in
the spirit of Rust.</p>
<p>This book is currently in development. If it is confusing in any way, or you have suggestions,
please post an issue in the <a href="https://github.com/intendednull/yewdux">repo</a> or ask in the
<a href="https://discord.gg/UmS6FKYa5a">Yew discord</a>.</p>
<h2 id="why-yewdux"><a class="header" href="#why-yewdux">Why Yewdux?</a></h2>
<p>State management in Yew can be difficult. Especially when many different components need access to
the same state. Properties and callbacks work great for simple relationships, however quickly become
cumbersome when you need to propagate state through many (potentially isolated) layers of
components. Yew's <a href="https://yew.rs/docs/concepts/contexts">context manager</a> does a decent job, and is
worth serious consideration, however it requires substantial boilerplate and is not that easy to
use.</p>
<p>This crate aims to provide a dead-simple, ergonomic approach to global state management. It
encourages modular state by providing easy setup and access to your shared state, allowing you to
write cleaner code while remaining productive.</p>
<p>It does <strong>not</strong> try to provide any additional patterns or features which aren't directly related to
accessing or manipulating shared state.</p>
<p>Yewdux was built with the following goals:</p>
<ul>
<li><strong>Simple</strong> - the only required trait is <a href="./store.html">Store</a>.</li>
<li><strong>Ergonomic</strong> - boilerplate is optional!</li>
<li><strong>Predictable</strong> - you have complete control over how state is changed.</li>
<li><strong>Selective</strong> - only render when you need to (see <a href="./reading.html#selectors">selectors</a>).</li>
<li><strong>Context agnostic</strong> - you can create and execute a <a href="./dispatch.html">dispatch</a> from anywhere.</li>
<li><strong>Complete component support</strong> - compatible with both functional and struct components.</li>
</ul>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<ul>
<li><a href="https://github.com/bounce-rs/bounce">Bounce</a> - The uncomplicated Yew State management library</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>Add Yewdux to your project's <code>Cargo.toml</code>. Make sure Yew has the &quot;csr&quot; feature (client side rendering):</p>
<h3 id="stable-release"><a class="header" href="#stable-release">Stable release:</a></h3>
<pre><code class="language-toml">[dependencies]
yew = { version = &quot;0.21&quot;, features = [&quot;csr&quot;] }
yewdux = &quot;0.10&quot;
</code></pre>
<h3 id="development-branch"><a class="header" href="#development-branch">Development branch:</a></h3>
<pre><code class="language-toml">[dependencies]
yew = { git = &quot;https://github.com/yewstack/yew.git&quot;, features = [&quot;csr&quot;] }
yewdux = { git = &quot;https://github.com/intendednull/yewdux.git&quot; }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart-example"><a class="header" href="#quickstart-example">Quickstart example</a></h1>
<p>Below you'll find a simple counter example, demonstrating how to read and write to shared state.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">extern crate yew;
</span>use yew::prelude::*;
use yewdux::prelude::*;

#[derive(Default, Clone, PartialEq, Store)]
struct State {
    count: u32,
}

#[function_component]
fn ViewCount() -&gt; Html {
    let (state, _) = use_store::&lt;State&gt;();
    html!(state.count)
}

#[function_component]
fn IncrementCount() -&gt; Html {
    let (_, dispatch) = use_store::&lt;State&gt;();
    let onclick = dispatch.reduce_mut_callback(|counter| counter.count += 1);

    html! {
        &lt;button {onclick}&gt;{&quot;+1&quot;}&lt;/button&gt;
    }
}

#[function_component]
fn App() -&gt; Html {
    html! {
        &lt;&gt;
        &lt;ViewCount /&gt;
        &lt;IncrementCount /&gt;
        &lt;/&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="additional-examples"><a class="header" href="#additional-examples">Additional examples</a></h2>
<p>Complete working examples can be found in the
<a href="https://github.com/intendednull/yewdux/tree/master/examples">examples</a> folder of github.</p>
<p>To run an example you'll need to install <a href="https://github.com/thedodd/trunk">trunk</a> (a rust wasm
bundler), then run the following command (replacing [example] with your desired example name):</p>
<pre><code class="language-bash">    trunk serve examples/[example]/index.html --open
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-a-store"><a class="header" href="#defining-a-store">Defining a Store</a></h1>
<p>A <a href="https://docs.rs/yewdux/0.8.1/yewdux/store/trait.Store.html">Store</a> represents state that is
shared application-wide. It is initialized on first access, and lives for application lifetime.</p>
<p>Implement <code>Store</code> for your state using the macro.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span>use yewdux::prelude::*;

#[derive(Default, PartialEq, Store)]
struct State {
    count: u32,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="store-attributes"><a class="header" href="#store-attributes">Store Attributes</a></h2>
<p>The <code>Store</code> derive macro supports several attributes to customize behavior:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, PartialEq, Store)]
#[store(storage = &quot;local&quot;)]              // Enable local storage persistence
#[store(storage_tab_sync = true)]        // Enable tab synchronization
#[store(listener(MyCustomListener))]     // Register custom listeners
#[store(derived_from(OtherStore))]       // Create derived state (immutable)
#[store(derived_from_mut(OtherStore))]   // Create derived state (mutable)
struct State {
    count: u32,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="manual-implementation"><a class="header" href="#manual-implementation">Manual Implementation</a></h2>
<p>It is also simple to define a <code>Store</code> manually. This is useful when you need finer control over how
it is created, or when to notify components.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">use yewdux::prelude::*;
</span>#[derive(PartialEq)]
struct State {
    count: u32,
}

impl Store for State {
    fn new(_cx: &amp;yewdux::Context) -&gt; Self {
        Self {
            count: Default::default(),
        }
    }

    fn should_notify(&amp;self, old: &amp;Self) -&gt; bool {
        // When this returns true, all components are notified and consequently re-render.
        self != old
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Note: implementing <code>Store</code> doesn't require any additional traits, however <code>Default</code> and
<code>PartialEq</code> are required for the macro.</em></p>
<p>See <a href="./derived_state.html">Derived State</a> for more information on creating stores that automatically update in response to changes in other stores.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-default-store-values"><a class="header" href="#setting-default-store-values">Setting default store values</a></h1>
<p>The best way to define the default value of your store is by manually implementing <code>Default</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">use yewdux::prelude::*;
</span>#[derive(PartialEq, Store)]
struct MyStore {
    foo: String,
    bar: String,
}

impl Default for MyStore {
    fn default() -&gt; Self {
        Self {
            foo: &quot;foo&quot;.to_string(),
            bar: &quot;bar&quot;.to_string(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Sometimes you may need additional context to set the initial value of your store. To do this, there
are a couple options.</p>
<p>You can set the value at the beginning of your application, before your app renders (like in your
main function).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate yewdux;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">#[derive(PartialEq, Store, Default)]
</span><span class="boring">struct MyStore {
</span><span class="boring">    foo: String,
</span><span class="boring">    bar: String,
</span><span class="boring">}
</span>fn main() {
    // Construct foo and bar however necessary
    let foo = &quot;foo&quot;.to_string();
    let bar = &quot;bar&quot;.to_string();
    // Run this before starting your app.
    Dispatch::&lt;MyStore&gt;::global().set(MyStore { foo, bar });
    // ... continue with your app setup
}
</code></pre></pre>
<p>You can also set the inital value from a function component. The <code>use_effect_with</code> hook can be used
to run the hook only once (just be sure to use empty deps).</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yew;
</span><span class="boring">extern crate yewdux;
</span><span class="boring">
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">use yew::prelude::*;
</span><span class="boring">#[derive(PartialEq, Store, Default)]
</span><span class="boring">struct MyStore {
</span><span class="boring">    foo: String,
</span><span class="boring">    bar: String,
</span><span class="boring">}
</span>#[function_component]
fn MyComponent() -&gt; Html {
    let dispatch = use_dispatch::&lt;MyStore&gt;();
    // This runs only once, on the first render of the component.
    use_effect_with(
        (), // empty deps
        move |_| {
            // Construct foo and bar however necessary
            let foo = &quot;foo&quot;.to_string();
            let bar = &quot;bar&quot;.to_string();
            dispatch.set(MyStore { foo, bar });
            || {}
        },
    );

    html! {
        // Your component html
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Keep in mind your store will still be initialized with <code>Store::new</code> (usually that's set to
<code>Default::default()</code>), however this is typically inexpensive.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="persistence"><a class="header" href="#persistence">Persistence</a></h1>
<p>Yewdux provides the <code>#[store]</code> macro to easily persist your state in either local or session storage.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">extern crate serde;
</span>use yewdux::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Default, PartialEq, Serialize, Deserialize, Store)]
#[store(storage = &quot;local&quot;)] // can also be &quot;session&quot;
struct State {
    count: u32,
}
<span class="boring">}
</span></code></pre></pre>
<p>This can also be done
<a href="https://github.com/intendednull/yewdux/blob/master/examples/listener/src/main.rs">manually</a>.</p>
<h2 id="tab-sync"><a class="header" href="#tab-sync">Tab sync</a></h2>
<p>Normally if your application is open in multiple tabs, the store is not updated in any tab other
than the current one. If you want storage to sync in all tabs, add <code>storage_tab_sync</code> to the macro.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">extern crate serde;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">use serde::{Serialize, Deserialize};
</span>#[derive(Default, Clone, PartialEq, Eq, Deserialize, Serialize, Store)]
#[store(storage = &quot;local&quot;, storage_tab_sync)]
struct State {
    count: u32,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="additional-listeners"><a class="header" href="#additional-listeners">Additional Listeners</a></h2>
<p>You can inject additional listeners into the <code>#[store]</code> macro.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">extern crate serde;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">use serde::{Serialize, Deserialize};
</span>#[derive(Default, Clone, PartialEq, Eq, Deserialize, Serialize, Store)]
#[store(storage = &quot;local&quot;, listener(LogListener))]
struct State {
    count: u32,
}

struct LogListener;
impl Listener for LogListener {
    type Store = State;

    fn on_change(&amp;mut self, _cx: &amp;yewdux::Context, state: Rc&lt;Self::Store&gt;) {
        yewdux::log::info!(&quot;Count changed to {}&quot;, state.count);
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derived-state"><a class="header" href="#derived-state">Derived State</a></h1>
<p>Derived state allows you to create state that automatically reacts to changes in another store. This is useful for:</p>
<ul>
<li>Computing derived values from your primary state</li>
<li>Creating focused views of larger state objects</li>
<li>Building dependent state relationships</li>
</ul>
<h2 id="defining-derived-state"><a class="header" href="#defining-derived-state">Defining Derived State</a></h2>
<p>There are two ways to create derived state:</p>
<ol>
<li>Using the <code>Store</code> macro with <code>derived_from</code> or <code>derived_from_mut</code> attributes</li>
<li>Manually implementing the <code>Store</code> trait and calling <code>derived_from</code> or <code>derived_from_mut</code></li>
</ol>
<h3 id="using-the-store-macro"><a class="header" href="#using-the-store-macro">Using the Store Macro</a></h3>
<p>The simplest approach is to use the <code>Store</code> derive macro with the <code>derived_from</code> or <code>derived_from_mut</code> attributes:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use yewdux::prelude::*;

// Original source state
#[derive(Default, Clone, PartialEq, Store)]
struct Count {
    count: u32,
}

// Immutable derived state - creates a new instance on change
#[derive(Default, Clone, PartialEq, Store)]
#[store(derived_from(Count))]
struct CountMultiplied {
    value: u32,
}

impl DerivedFrom&lt;Count&gt; for CountMultiplied {
    fn on_change(&amp;self, state: Rc&lt;Count&gt;) -&gt; Self {
        Self {
            value: state.count * 10,
        }
    }
}

// Mutable derived state - updates in place
#[derive(Default, Clone, PartialEq, Store)]
#[store(derived_from_mut(Count))]
struct CountIsEven {
    status: bool,
}

impl DerivedFromMut&lt;Count&gt; for CountIsEven {
    fn on_change(&amp;mut self, state: Rc&lt;Count&gt;) {
        self.status = state.count % 2 == 0;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="manual-implementation-1"><a class="header" href="#manual-implementation-1">Manual Implementation</a></h3>
<p>For more control, you can implement <code>Store</code> manually and register the relationship in your <code>new</code> method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Clone, PartialEq)]
struct CountIsEven {
    status: bool,
}

impl DerivedFromMut&lt;Count&gt; for CountIsEven {
    fn on_change(&amp;mut self, state: Rc&lt;Count&gt;) {
        self.status = state.count % 2 == 0;
    }
}

impl Store for CountIsEven {
    fn new(cx: &amp;yewdux::Context) -&gt; Self {
        // Register this state as derived from `Count`
        cx.derived_from_mut::&lt;Count, Self&gt;();

        // Initialize with current Count value
        let status = cx.get::&lt;Count&gt;().count % 2 == 0;
        Self { status }
    }

    fn should_notify(&amp;self, old: &amp;Self) -&gt; bool {
        self != old
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="using-derived-state"><a class="header" href="#using-derived-state">Using Derived State</a></h2>
<p>Using derived state is identical to using any other store:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[function_component]
fn App() -&gt; Html {
    let (count, dispatch) = use_store::&lt;Count&gt;();
    let is_even = use_store_value::&lt;CountIsEven&gt;();
    let multiplied = use_store_value::&lt;CountMultiplied&gt;();
    
    let onclick = dispatch.reduce_mut_callback(|state| state.count += 1);

    html! {
        &lt;&gt;
        &lt;p&gt;{&quot;Count: &quot;}{ count.count }&lt;/p&gt;
        &lt;p&gt;{&quot;Is Even: &quot;}{ is_even.status.to_string() }&lt;/p&gt;
        &lt;p&gt;{&quot;Multiplied by 10: &quot;}{ multiplied.value }&lt;/p&gt;
        &lt;button {onclick}&gt;{&quot;+1&quot;}&lt;/button&gt;
        &lt;/&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>When you use <code>derived_from</code> or <code>derived_from_mut</code>:</p>
<ol>
<li>A listener is registered that watches for changes in the source state</li>
<li>When the source state changes, your <code>on_change</code> implementation is called</li>
<li>Your derived state is updated either by creating a new instance (<code>DerivedFrom</code>) or by modifying it in place (<code>DerivedFromMut</code>)</li>
<li>Components using the derived state are re-rendered</li>
</ol>
<p>This provides a clean, type-safe way to create computed or dependent state without manual synchronization.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-dispatch"><a class="header" href="#creating-a-dispatch">Creating a dispatch</a></h1>
<p>A <a href="https://docs.rs/yewdux/latest/yewdux/dispatch/struct.Dispatch.html">Dispatch</a> is the primary
interface to access your <a href="https://docs.rs/yewdux/latest/yewdux/store/trait.Store.html">Store</a>. It
can be used to read and write changes to state in various ways.</p>
<h2 id="hooks"><a class="header" href="#hooks">Hooks</a></h2>
<p>A dispatch is provided when using the functional hook, which is only available in yew functional
components.</p>
<p><strong>IMPORTANT</strong>: Like other hooks, all yewdux hooks must be used at the top level of a function
component.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">extern crate yew;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">use yew::prelude::*;
</span>#[derive(Default, PartialEq, Store)]
struct State {
    count: u32,
}

#[function_component]
fn MyComponent() -&gt; Html {
    let (state, dispatch) = use_store::&lt;State&gt;();
    html! {
        // Component stuff here
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>See <a href="https://docs.rs/yewdux/latest/yewdux/functional/index.html">the docs</a> for a full list of
available hooks.</p>
<h2 id="manually"><a class="header" href="#manually">Manually</a></h2>
<p>To create a dispatch, you need only provide the desired store type. This is available in <strong>any</strong>
rust code, not just yew components.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">#[derive(Default, PartialEq, Store)]
</span><span class="boring">struct State {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span>let dispatch = Dispatch::&lt;State&gt;::global();
<span class="boring">}
</span></code></pre></pre>
<p><strong>NOTE</strong>: Here we create a global dispatch, which is only available for wasm targets. See
<a href="./ssr.html">SSR support</a> for alternatives.</p>
<h1 id="changing-state"><a class="header" href="#changing-state">Changing state</a></h1>
<p><code>Dispatch</code> provides many options for changing state. Here are a few handy methods. For a full list
see the <a href="https://docs.rs/yewdux/latest/yewdux/dispatch/struct.Dispatch.html#">docs</a></p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">extern crate yew;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">use yew::prelude::*;
</span>#[derive(Default, PartialEq, Store)]
struct State {
    count: u32,
}

// Create a global dispatch
let dispatch = Dispatch::&lt;State&gt;::global();

// Set the value immediately
dispatch.set(State { count: 0 });

// Set the value immediately based on the last value
dispatch.reduce(|state| State { count: state.count + 1}.into());

// Create a callback to set the value when a button is clicked
let onclick = dispatch.reduce_callback(|state| State { count: state.count + 1}.into());
html! {
    &lt;button {onclick}&gt;{&quot;Increment (+1)&quot;}&lt;/button&gt;
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="mut-reducers"><a class="header" href="#mut-reducers">Mut reducers</a></h2>
<p>There are <code>_mut</code> variants to every reducer function. This way has less boilerplate, and requires
your <code>Store</code> to implement <code>Clone</code>. Your <code>Store</code> <em>may</em> be cloned once per mutation,</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">extern crate yew;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">use yew::prelude::*;
</span>#[derive(Default, PartialEq, Clone, Store)]
struct State {
    count: u32,
}

// Create a global dispatch
let dispatch = Dispatch::&lt;State&gt;::global();

// Mutate the current value
dispatch.reduce_mut(|state| state.count += 1);

// Create a callback to mutate the value when a button is clicked
let onclick = dispatch.reduce_mut_callback(|counter| counter.count += 1);
html! {
    &lt;button {onclick}&gt;{&quot;Increment (+1)&quot;}&lt;/button&gt;
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="predictable-mutations"><a class="header" href="#predictable-mutations">Predictable mutations</a></h2>
<p>Yewdux supports predictable mutation. Simply define your message and apply it.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">extern crate yew;
</span>use std::rc::Rc;

use yew::prelude::*;
use yewdux::prelude::*;

#[derive(Default, PartialEq, Clone, Store)]
struct State {
    count: u32,
}

enum Msg {
    AddOne,
}

impl Reducer&lt;State&gt; for Msg {
    fn apply(self, state: Rc&lt;State&gt;) -&gt; Rc&lt;State&gt; {
        match self {
            Msg::AddOne =&gt; State { count: state.count + 1 }.into(),
        }
    }
}

let dispatch = Dispatch::&lt;State&gt;::global();

dispatch.apply(Msg::AddOne);

let onclick = dispatch.apply_callback(|_| Msg::AddOne);
html! {
    &lt;button {onclick}&gt;{&quot;Increment (+1)&quot;}&lt;/button&gt;
};
<span class="boring">}
</span></code></pre></pre>
<h3 id="tip"><a class="header" href="#tip">Tip</a></h3>
<p><code>Rc::make_mut</code> is handy if you prefer CoW:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">#[derive(Default, PartialEq, Clone, Store)]
</span><span class="boring">struct State {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">enum Msg {
</span><span class="boring">    AddOne,
</span><span class="boring">}
</span>impl Reducer&lt;State&gt; for Msg {
    fn apply(self, mut state: Rc&lt;State&gt;) -&gt; Rc&lt;State&gt; {
        let state_mut = Rc::make_mut(&amp;mut state);

        match self {
            Msg::AddOne =&gt; state_mut.count += 1,
        };

        state
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="future-support"><a class="header" href="#future-support">Future support</a></h2>
<p>Because a <code>Dispatch</code> may be created and executed from anywhere, Yewdux has innate future support.
Just use it normally, no additonal setup is needed.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">extern crate yew;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">use yew::prelude::*;
</span>
#[derive(Default, PartialEq, Store)]
struct User {
    name: Option&lt;Rc&lt;str&gt;&gt;,
}

async fn get_user() -&gt; User {
    User { name: Some(&quot;bob&quot;.into()) }
}

let dispatch = Dispatch::&lt;User&gt;::global();
// Use yew::platform::spawn_local to run a future.
let future = async move {
    let user = get_user().await;
    dispatch.set(user);
};
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-state"><a class="header" href="#reading-state">Reading state</a></h1>
<p>To get the current state of your store immediately, use <code>Dispatch::get</code>:</p>
<p><strong>IMPORTANT</strong>: Reading the state this way <strong>does not</strong> provide any sort of change detection, and
your component <strong>will not</strong> automatically re-render when state changes.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span>use std::rc::Rc;

use yewdux::prelude::*;

#[derive(PartialEq, Default, Store)]
struct State {
    count: u32,
}

// Create a dispatch from the global context. This works for non-global contexts too, we would just
// pass in the context we want.
let dispatch = Dispatch::&lt;State&gt;::global();
let state: Rc&lt;State&gt; = dispatch.get();
<span class="boring">}
</span></code></pre></pre>
<h2 id="subscribing-to-your-store"><a class="header" href="#subscribing-to-your-store">Subscribing to your store</a></h2>
<p>In order for your component to know when state changes, we need to subscribe.</p>
<h3 id="function-components"><a class="header" href="#function-components">Function components</a></h3>
<p>The <code>use_store</code> hook automatically subscribes to your store, and re-renders when state changes. This
<strong>must</strong> be called at the top level of your function component.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">extern crate yew;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">use yew::prelude::*;
</span><span class="boring">#[derive(PartialEq, Default, Store)]
</span><span class="boring">struct State {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span>#[function_component]
fn ViewCount() -&gt; Html {
    let (state, dispatch) = use_store::&lt;State&gt;();
    html!(state.count)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="struct-components"><a class="header" href="#struct-components">Struct components</a></h3>
<p>For struct components we need to subscribe manually. This way allows much finer control, at the cost
of extra boilerplate.</p>
<p><strong>IMPORTANT</strong>: Remember to hold onto your dispatch instance. Dropping it will drop the entire
subscription, and you will <strong>not</strong> receive changes to state.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">extern crate yew;
</span>use std::rc::Rc;

use yew::prelude::*;
use yewdux::prelude::*;

#[derive(PartialEq, Default, Clone, Store)]
struct State {
    count: u32,
}

struct MyComponent {
    dispatch: Dispatch&lt;State&gt;,
    state: Rc&lt;State&gt;,

}

enum Msg {
    StateChanged(Rc&lt;State&gt;),
}

impl Component for MyComponent {
    type Properties = ();
    type Message = Msg;

    fn create(ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
        // The callback for receiving updates to state.
        let callback = ctx.link().callback(Msg::StateChanged);
        // Subscribe to changes in state. New state is received in `update`. Be sure to save this,
        // dropping it will unsubscribe.
        let dispatch = Dispatch::&lt;State&gt;::global().subscribe_silent(callback);
        Self {
            // Get the current state.
            state: dispatch.get(),
            dispatch,
        }
    }

    fn update(&amp;mut self, ctx: &amp;Context&lt;Self&gt;, msg: Msg) -&gt; bool {
        match msg {
            // Receive new state.
            Msg::StateChanged(state) =&gt; {
                self.state = state;

                // Only re-render this component if count is greater that 0 (for this example).
                if self.state.count &gt; 0 {
                    true
                } else {
                    false
                }
            }
        }
    }

    fn view(&amp;self, ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
        let count = self.state.count;
        let onclick = self.dispatch.reduce_mut_callback(|s| s.count += 1);
        html! {
            &lt;&gt;
            &lt;h1&gt;{ count }&lt;/h1&gt;
            &lt;button onclick={onclick}&gt;{&quot;+1&quot;}&lt;/button&gt;
            &lt;/&gt;
        }
    }

}
<span class="boring">}
</span></code></pre></pre>
<h1 id="selectors"><a class="header" href="#selectors">Selectors</a></h1>
<p>Sometimes a component will only care about a particular part of state, and only needs to re-render
when that part changes. For this we have the <code>use_selector</code> hook.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">extern crate yew;
</span>use yewdux::prelude::*;
use yew::prelude::*;

#[derive(Default, Clone, PartialEq, Store)]
struct User {
    first_name: String,
    last_name: String,
}

#[function_component]
fn DisplayFirst() -&gt; Html {
    // This will only re-render when the first name has changed. It will **not** re-render if any
    // other field has changed.
    //
    // Note: we are cloning a string. Probably insignificant for this example, however
    // sometimes it may be beneficial to wrap fields that are expensive to clone in an `Rc`.
    let first_name = use_selector(|state: &amp;User| state.first_name.clone());

    html! {
        &lt;p&gt;{ first_name }&lt;/p&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="capturing-your-environment"><a class="header" href="#capturing-your-environment">Capturing your environment</a></h2>
<p>For selectors that need to capture variables from their environment, be sure to provide them as
dependencies to <code>use_selector_with_deps</code>. Otherwise your selector won't update correctly!</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">extern crate yew;
</span>use std::collections::HashMap;

use yewdux::prelude::*;
use yew::prelude::*;

#[derive(Default, Clone, PartialEq, Store)]
struct Items {
    inner: HashMap&lt;u32, String&gt;,
}

#[derive(Clone, PartialEq, Properties)]
struct DisplayItemProps {
    item_id: u32,
}

#[function_component]
fn DisplayItem(props: &amp;DisplayItemProps) -&gt; Html {
    // For multiple dependencies, try using a tuple: (dep1, dep2, ..)
    let item = use_selector_with_deps(
        |state: &amp;Items, item_id| state.inner.get(item_id).cloned(),
        props.item_id,
    );
    // Only render the item if it exists.
    let item = match item.as_ref() {
        Some(item) =&gt; item,
        None =&gt; return Default::default(),
    };

    html! {
        &lt;p&gt;{ item }&lt;/p&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="listeners"><a class="header" href="#listeners">Listeners</a></h1>
<p>Listeners are component-less subscribers. They are used to describe side-effects that should happen
whenever state changes. They live for application lifetime, and are created with <code>init_listener</code>.</p>
<p>Here's a simple listener that logs the current state whenever it changes.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yew;
</span><span class="boring">extern crate yewdux;
</span><span class="boring">use yew::prelude::*;
</span>use std::rc::Rc;

use yewdux::prelude::*;

#[derive(Default, Clone, PartialEq, Debug, Store)]
struct State {
    count: u32,
}

struct StateLogger;
impl Listener for StateLogger {
    // Here's where we define which store we are listening to.
    type Store = State;
    // Here's where we decide what happens when `State` changes.
    fn on_change(&amp;self, _cx: &amp;yewdux::Context, state: Rc&lt;Self::Store&gt;) {
        yewdux::log::info!(&quot;state changed: {:?}&quot;, state);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Can can start the listener by calling <code>init_listener</code> somewhere in our code. A good place to put it is
the store constructor.</p>
<p><strong>NOTE</strong>: Successive calls to <code>init_listener</code> on the same type will do nothing.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">#[derive(Default, PartialEq, Debug)]
</span><span class="boring">struct State {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">struct StateLogger;
</span><span class="boring">impl Listener for StateLogger {
</span><span class="boring">    // Here's where we say which store we want to subscribe to.
</span><span class="boring">    type Store = State;
</span><span class="boring">
</span><span class="boring">    fn on_change(&amp;self, _cx: &amp;yewdux::Context, state: Rc&lt;Self::Store&gt;) {
</span><span class="boring">        yewdux::log::info!(&quot;state changed: {:?}&quot;, state);
</span><span class="boring">    }
</span><span class="boring">}
</span>
impl Store for State {
    fn new(cx: &amp;yewdux::Context) -&gt; Self {
        init_listener(|| StateLogger, cx);
        Default::default()
    }

    fn should_notify(&amp;self, other: &amp;Self) -&gt; bool {
        self != other
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="tracking-state"><a class="header" href="#tracking-state">Tracking state</a></h2>
<p>Sometimes it's useful to keep track of how a store has been changing over time. However this should
not be done in the listener itself. Notice <code>Listener::on_change</code> takes an immutable reference. This
is necessary because otherwise we start to run into borrowing issues when listeners are triggered
recursively.</p>
<p>To track changes we can instead use a separate store that listens to the store we want to track.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">#[derive(Default, PartialEq, Debug)]
</span><span class="boring">struct State {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span>
#[derive(Default, PartialEq, Debug, Store, Clone)]
struct ChangeTracker  {
    count: u32,
}

struct ChangeTrackerListener;
impl Listener for StateLogger {
    type Store = State;

    fn on_change(&amp;self, cx: &amp;yewdux::Context, state: Rc&lt;Self::Store&gt;) {
       let dispatch = Dispatch::&lt;ChangeTracker&gt;::new(cx);
       dipatch.reduce_mut(|state| state.count += 1);
       let count = dispatch.get().count;
       println!(&quot;State has changed {} times&quot;, count);
    }
}

impl Store for State {
    fn new(cx: &amp;yewdux::Context) -&gt; Self {
        init_listener(|| ChangeTrackerListener, cx);
        Default::default()
    }

    fn should_notify(&amp;self, other: &amp;Self) -&gt; bool {
        self != other
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contexts"><a class="header" href="#contexts">Contexts</a></h1>
<p>Contexts contains the state of your Stores. You rarely (if ever) need to manage them manually, but
it's useful to understand how they work.</p>
<p>You can easily create a new local context with <code>Context::new</code>. Then just pass it into a dispatch and
you have your very own locally managed store!</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yew;
</span><span class="boring">extern crate yewdux;
</span>use yew::prelude::*;
use yewdux::prelude::*;

#[derive(Clone, PartialEq, Default, Store)]
struct Counter(u32);

let cx = yewdux::Context::new();
let dispatch = Dispatch::&lt;Counter&gt;::new(&amp;cx);
<span class="boring">}
</span></code></pre></pre>
<p>Changes to one context are not reflected in any others:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">#[derive(Clone, PartialEq, Default, Store)]
</span><span class="boring">struct Counter(u32);
</span>let cx_1 = yewdux::Context::new();
let dispatch_1 = Dispatch::&lt;Counter&gt;::new(&amp;cx_1);

let cx_2 = yewdux::Context::new();
let dispatch_2 = Dispatch::&lt;Counter&gt;::new(&amp;cx_2);

dispatch_1.set(Counter(1));
dispatch_2.set(Counter(2));

assert!(dispatch_1.get() != dispatch_2.get());
<span class="boring">}
</span></code></pre></pre>
<h2 id="the-global-context"><a class="header" href="#the-global-context">The Global Context</a></h2>
<p>You may already be familar with the global context. This is what you are using when you create a
dispatch with <code>Dispatch::global</code>. The global context is thread-local, meaning you can access it from
anywhere in your code as long as it's on the same thread (for wasm this is effectively everywhere).</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yewdux;
</span><span class="boring">use yewdux::prelude::*;
</span><span class="boring">#[derive(Clone, PartialEq, Default, Store)]
</span><span class="boring">struct Counter(u32);
</span>// These are equivalent!
let dispatch_1 = Dispatch::&lt;Counter&gt;::global();
let dispatch_2 = Dispatch::&lt;Counter&gt;::new(&amp;yewdux::Context::global());

dispatch_1.set(Counter(1));

assert!(dispatch_1.get() == dispatch_2.get());
<span class="boring">}
</span></code></pre></pre>
<h2><strong>IMPORTANT</strong>: Use of global context is only supported for wasm targets. See <a href="./ssr.html">ssr support</a>
for more details.</h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ssr-support"><a class="header" href="#ssr-support">SSR Support</a></h1>
<p>By default Yewdux uses a global <code>Context</code> that is shared thread-locally. This means we can share
state from anywhere in our code as long as it's within the same thread. Wasm applications are
strictly single threaded (without workers), so it isn't a problem.</p>
<p>However the same cannot be said for server side rendering. It is very possible the server is
executing in a multi-threaded environment, which could cause various problems for Yewdux's
single-threaded assumption.</p>
<p>While multi-threaded globally shared state is technically possible, it is currently not supported.</p>
<p>Instead Yewdux offers a custom component to hold your shared application state: <code>YewduxRoot</code>. This
ensures all state is kept inside your Yew app.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yew;
</span><span class="boring">extern crate yewdux;
</span>use yew::prelude::*;
use yewdux::prelude::*;

#[derive(Default, Clone, PartialEq, Eq, Store)]
struct State {
    count: u32,
}

#[function_component]
fn Counter() -&gt; Html {
    let (state, dispatch) = use_store::&lt;State&gt;();
    let onclick = dispatch.reduce_mut_callback(|state| state.count += 1);
    html! {
        &lt;&gt;
        &lt;p&gt;{ state.count }&lt;/p&gt;
        &lt;button {onclick}&gt;{&quot;+1&quot;}&lt;/button&gt;
        &lt;/&gt;
    }
}

#[function_component]
fn App() -&gt; Html {
    // YewduxRoot must be kept above all components that use any of your stores.
    html! {
        &lt;YewduxRoot&gt;
            &lt;Counter /&gt;
        &lt;/YewduxRoot&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Yewdux hooks automatically detect when YewduxRoot is present, and use it accordingly.</p>
<h2 id="ssr-with-struct-components"><a class="header" href="#ssr-with-struct-components">SSR with struct components</a></h2>
<p>For struct component support, refer to the <a href="https://yew.rs/docs/advanced-topics/struct-components/hoc">higher order components
pattern</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate yew;
</span><span class="boring">extern crate yewdux;
</span>use std::rc::Rc;

use yew::prelude::*;
use yewdux::prelude::*;

#[derive(Default, Clone, PartialEq, Eq, Store)]
struct State {
    count: u32,
}

#[derive(Properties, Clone, PartialEq)]
struct Props {
    dispatch: Dispatch&lt;State&gt;,
}

enum Msg {
    StateChanged(Rc&lt;State&gt;),
}

struct MyComponent {
    state: Rc&lt;State&gt;,
    dispatch: Dispatch&lt;State&gt;,
}

impl Component for MyComponent {
    type Properties = Props;
    type Message = Msg;

    fn create(ctx: &amp;Context&lt;Self&gt;) -&gt; Self {
        let callback = ctx.link().callback(Msg::StateChanged);
        let dispatch = ctx.props().dispatch.clone().subscribe_silent(callback);
        Self {
            state: dispatch.get(),
            dispatch,
        }
    }

    fn update(&amp;mut self, _ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {
        match msg {
            Msg::StateChanged(state) =&gt; {
                self.state = state;
                true
            }
        }
    }

    fn view(&amp;self, ctx: &amp;Context&lt;Self&gt;) -&gt; Html {
        let count = self.state.count;
        let onclick = self.dispatch.reduce_mut_callback(|s| s.count += 1);
        html! {
            &lt;&gt;
            &lt;h1&gt;{ count }&lt;/h1&gt;
            &lt;button onclick={onclick}&gt;{&quot;+1&quot;}&lt;/button&gt;
            &lt;/&gt;
        }
    }

}

#[function_component]
fn MyComponentHoc() -&gt; Html {
    let dispatch = use_dispatch::&lt;State&gt;();

    html! {
        &lt;MyComponent {dispatch} /&gt;
    }
}


#[function_component]
fn App() -&gt; Html {
    // YewduxRoot must be kept above all components that use any of your stores.
    html! {
        &lt;YewduxRoot&gt;
            &lt;MyComponentHoc /&gt;
        &lt;/YewduxRoot&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
